{"./":{"url":"./","title":"介绍","keywords":"","body":"Lua Tutorial Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。 设计目的 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 Lua 特性 轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。 可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。 其它特性: 支持面向过程(procedure-oriented)编程和函数式编程(functional programming)； 自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象； 语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持； 通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。 Lua 应用场景 游戏开发 独立应用脚本 Web 应用脚本 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench 安全系统，如入侵检测系统 "},"chapter01/":{"url":"chapter01/","title":"起步","keywords":"","body":"起步 按照传统，第一个程序从Hello World开始： print(\"Hello World!\") 假设你将上面语句保存到文件hello.lua中，那么你可以在命令行执行： lua hello.lua 来看一个稍微复杂的例子，下面的程序定义了一个函数来计算给定数字的阶乘，询问用户一个数字，并打印它的阶乘： -- defines a factorial function function fact (n) if n == 0 then return 1 else return n * fact(n-1) end end print(\"enter a number:\") a = io.read(\"*number\") -- read a number print(fact(a)) "},"chapter01/chunks.html":{"url":"chapter01/chunks.html","title":"Chunks","keywords":"","body":"Chunks Lua执行的每一段代码，例如文件或交互模式下的单行代码，都是一个块。更具体地说，块是简单的一系列语句。 a = 1 b = a*2 a = 1; b = a*2; a = 1 ; b = a*2 a = 1 b = a*2 -- ugly, but valid 一个Chunk可以是一个语句，也可以是一系列语句的组合，还可以是函数，Chunk可以很大，在Lua中几个MByte的Chunk是很常见的。 交互式编程 可以通过使用lua -i或lua命令开启交互式命令行： Lua 5.2.4 Copyright (C) 1994-2015 Lua.org, PUC-Rio > 在命令行中，输入以下命令： > print(\"Hello World!\") 按回车后，得到执行结果如下： > print(\"Hello World!\") Hello World! > 脚本式编程 我们可以将lua代码保存到.lua结尾的文件中，然后执行，例如，将以下内容保存到hello.lua文件中： print(\"Hello World!\") 使用lua执行脚本，得到结果如下： > lua hello.lua Hello World! 我们也可以将上面脚本修改成以下形式： #!/usr/bin/env lua print(\"Hello World!\") 我们可以给hello.lua添加执行权限chmod a+x hello.lua，然后执行它： > ./hello.lua Hello World! "},"chapter01/variables.html":{"url":"chapter01/variables.html","title":"变量","keywords":"","body":"变量 变量在使用前，必须在代码中进行声明，即创建该变量。 编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。 Lua变量有三种类型：全局变量、局部变量、表中的域。 Lua中的变量全是全局变量，那怕是语句块或是函数里，除非用local显式声明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为nil。 -- test.lua a = 5 -- global variables local b = 5 -- local variables function joke() c = 5 -- global variables local d = 6 -- local variables end joke() print(c, d) --> 5 nil do local a = 6 -- local variables b = 6 -- global variables print(a, b); --> 6 6 end print(a, b) --> 5 6 赋值语句 赋值是改变一个变量的值和改变表域的最基本的方法。 a = \"hello\" t.n = t.n + 1 也可以对多个变量同时赋值： a, b = 1, 2 -- 等价于：a = 1; b = 2 print(a, b) --> 1 2 a, b = b, a -- 交换a和b的值 print(1, b) --> 2 1 当变量个数和值的个数不一致时，lua执行以下两条规则： 变量个数 > 值的个数：按变量个数补足nil 变量个数 "},"chapter01/identifiers.html":{"url":"chapter01/identifiers.html","title":"标志符及关键字","keywords":"","body":"标志符及关键字 标志符 标示符：字母或者下划线开头的字母、下划线、数字序列。 最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。 Lua不允许使用特殊字符如@、$和%来定义标示符。Lua是一个区分大小写的编程语言。 以下列出了一些正确的标志符： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal 关键字 Lua有以下关键字，它们不能用于定义关键字： and break do else elseif end false for function if in local nil not or repeat return then true until while "},"chapter01/comment.html":{"url":"chapter01/comment.html","title":"注释","keywords":"","body":"注释 Lua中分单行注释和多行注释： 单行注释：以--开头，一直到行尾结束 多行注释：以--[[开始，以]]结束，中间的内容都是注释，有些时候习惯以--]]结束注释 例如： -- 这是单行注释 --[[ 这里 是 多行注释 ]] "},"chapter02/":{"url":"chapter02/","title":"数据类型","keywords":"","body":"数据类型 Lua是动态类型语言，变量不需要类型定义，使用时直接赋值即可。 Lua有8个基本数据类型：nil、boolean、number、string、function、userdata、thread、table 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false） boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。 我们可以使用type函数测试给定变量或者值的类型： print(type(\"Hello world\")) --> string print(type(10.4*3)) --> number print(type(print)) --> function print(type(type)) --> function print(type(true)) --> boolean print(type(nil)) --> nil print(type(type(X))) --> string "},"chapter02/nil.html":{"url":"chapter02/nil.html","title":"Nil","keywords":"","body":"Nil Lua中特殊的类型，他只有一个值：nil；一个全局变量没有被赋值以前默认值为nil；给全局变量负nil可以删除该变量。 print(type(a)) --> nil print(a == nil) --> true "},"chapter02/boolean.html":{"url":"chapter02/boolean.html","title":"Boolean","keywords":"","body":"Boolean boolean类型只有两个值：true和false。 print(type(true)) --> boolean print(type(false)) --> boolean print(type(nil)) --> nil 在做条件判断时，Lua把false和nil都看成是false： -- test.lua if false or nil then print('at least one of them is false') else print('both of them are false') end 执行结果如下： > lua test.lua both of them are false "},"chapter02/number.html":{"url":"chapter02/number.html","title":"Number","keywords":"","body":"Number Lua中只有一种number类型，那就是double类型（双精度浮点数）。 与其他语言相似，数字类型包含整数部分，可选小数部分以及可选指数部分。下面是一些数字常量的例子： 4 0.4 4.57e-3 0.3e12 5e+20 "},"chapter02/string.html":{"url":"chapter02/string.html","title":"String","keywords":"","body":"String 字符串由一对引号（双引号或单引号）括起来表示： str1 = \"this is string1\" str2 = 'this is string2' 也可以由两个方括号[[]]括起来表示： html = [[ Document ]] 在字符串中可以使用转义字符\\来进行转义，Lua包含以下转义字符： \\a bell \\b back space -- 后退 \\f form feed -- 换页 \\n newline -- 换行 \\r carriage return -- 回车 \\t horizontal tab -- 制表 \\v vertical tab \\\\ backslash -- \"\\\" \\\" double quote -- 双引号 \\' single quote -- 单引号 \\[ left square bracket -- 左中括号 \\] right square bracket -- 右中括号 运行时，Lua会自动在string和number之间转换，当一个string遇到算数运算符时，string会被转换成number， 反过来，当一个number遇到string连接符..时，会自动将number转换成string。 print(\"10\" + 1) --> 11 print(\"10 + 1\") --> 10 + 1 print(\"-5.3e - 10\" * 2) --> -1.06e-9 print(\"hello\" + 1) --> stdin:1: attempt to perform arithmetic on a string value print(10 .. 20) --> 1020 有些时候，我们需要显式对string或number进行相互转换，tostring()用于将number或其他类型转换成string， tonumber()用于将string转换成number，当tonumber()遇到不能转换成number的参数时，它将返回nil。 print(type(tostring(1))) --> string print(type(tostring(nil))) --> string print(type(tostring(true))) --> string print(type(tonumber(\"1\"))) --> number print(type(tonumber(\"hello\"))) --> nil print(type(tonumber(true))) --> nil "},"chapter02/table.html":{"url":"chapter02/table.html","title":"Table","keywords":"","body":"Table 最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表： local tab1 = {} local tab2 = {\"Hello\", \"World\", \"!\"} Lua中的table其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。 -- table_test.lua a = {} a[\"key\"] = \"value\" a[10] = 20 for k, v in pairs(a) do print(k .. \" : \" .. v) end 脚本执行结果是： $ lua table_test.lua 10 : 20 key : value 与其他语言不同的是，lua中的table下标不是从0开始，而是从1开始： -- table_test2.lua a2 = {\"Hello\", \"World\", \"!\"} for k, v in pairs(a2) do print(k .. \" : \" .. v) end 脚本执行结果如下： $ lua table_test2.lua 1 : Hello 2 : World 3 : ! table不会固定长度，有新数据添加时，table长度自动增长，没有初始的table都是nil： a3 = {} for i = 1, 10 do a3[i] = i end a3[\"k\"] = \"v\" print(a3[1]) --> 1 print(a3[10]) --> 10 print(a3[11]) --> nil print(a3[\"k\"]) --> v print(a3[\"k2\"]) --> nil "},"chapter02/function.html":{"url":"chapter02/function.html","title":"Function","keywords":"","body":"Function 函数是第一类值（和其他变量相同），意味着函数可以存储在变量中，可以作为函数的参数，也可以作为函数的返回值。 这个特性给了语言很大的灵活性：一个程序可以重新定义函数增加新的功能或者为了避免运行不可靠代码创建安全运行环境而隐藏函数， 此外这特性在Lua实现面向对象中也起了重要作用。 Lua可以调用lua或者 实现的函数，Lua所有标准库都是用C实现的。标准库包括string库、table库、I/O库、OS库、算术库、debug库。 -- function_test.lua function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) end end print(factorial1(5)) factorial2 = factorial1 print(factorial2(5)) 脚本执行结果是： $ lua function_test.lua 120 120 function可以以匿名函数（anonymous function）的方式通过参数传递： -- function_test2.lua function testFun(tab,fun) for k ,v in pairs(tab) do print(fun(k,v)); end end tab={key1=\"val1\",key2=\"val2\"}; testFun(tab, function(key,val) return key..\"=\"..val; end ); 脚本执行结果如下： $ lua function_test2.lua key1 = val1 key2 = val2 "},"chapter02/thread.html":{"url":"chapter02/thread.html","title":"Thread","keywords":"","body":"Thread 在Lua里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多， 拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 "},"chapter02/userdata.html":{"url":"chapter02/userdata.html","title":"Userdata","keywords":"","body":"Userdata userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型， 可以将任意C/C++的任意数据类型的数据（通常是struct和指针）存储到Lua变量中调用。 "},"chapter03/":{"url":"chapter03/","title":"表达式","keywords":"","body":"表达式 Lua中的表达式包括数字常量、字符串常量、变量、一元和二元运算符、函数调用。还可以是非传统的函数定义和表构造。 "},"chapter03/arithmetic.html":{"url":"chapter03/arithmetic.html","title":"算数运算符","keywords":"","body":"算数运算符 二元运算符：+(加) -(减) *(乘) /(除) ^(幂) %(取余) 一元运算符：-(负) a = 10 b = 7 print(a + b) --> 17 print(a - b) --> 3 print(a * b) --> 70 print(a / b) --> 1.4285714285714 print(a ^ b) --> 10000000 print(a % b) --> 3 print(-a) --> -10 "},"chapter03/relational.html":{"url":"chapter03/relational.html","title":"关系运算符","keywords":"","body":"关系运算符 ==(等于) ~=(不等) >(大于) (小于) >=(大于等于) (小于等于) a = 10 b = 7 print(a == b) --> false print(a ~= b) --> true print(a > b) --> true print(a false print(a >= b) --> true print(a false Lua比较数字时按数字大小进行，比较字符串时按字母顺序进行，但是字母顺序依赖本地环境。 "},"chapter03/logical.html":{"url":"chapter03/logical.html","title":"逻辑运算符","keywords":"","body":"逻辑运算符 and(与) or(或) not(非) 逻辑运算符认为false和nil是false，其他为真，0也是true。 and和or的运算结果不是true和false，而是和它的两个操作数相关。 not的结果一直返回false或者true。 print(4 and 5) --> 5 print(nil and 13) --> nil print(false and 13) --> false print(4 or 5) --> 4 print(false or 5) --> 5 print(not nil) --> true print(not false) --> true print(not 0) --> false print(not not nil) --> false "},"chapter03/concatenation.html":{"url":"chapter03/concatenation.html","title":"连接运算符","keywords":"","body":"连接运算符 ..：字符串连接，如果操作数为数字，Lua将数字转成字符串 print(\"Hello \" .. \"World\") --> Hello World print(0 .. 1) --> 01 "},"chapter03/other.html":{"url":"chapter03/other.html","title":"其他运算符","keywords":"","body":"其他运算符 #：一元运算符，返回字符串或表的长度。 print(#\"Hello World!\") --> 12 print(#{\"Hello\", \"World\", \"!\"}) --> 3 "},"chapter03/precedence.html":{"url":"chapter03/precedence.html","title":"运算符优先级","keywords":"","body":"运算符优先级 优先级从高到低如下： ^ not -(负) * / % + - .. = ~= == and or "},"chapter04/":{"url":"chapter04/","title":"控制结构","keywords":"","body":"控制结构 Lua提供了一个小的和常规的控制结构集合，如用于条件判断的if和用于迭代的while、repeat、for。 所有控制结构语句都有一个终止符： end终止符用于if、while、for until终止符用于repeat "},"chapter04/if.html":{"url":"chapter04/if.html","title":"if语句","keywords":"","body":"if语句 if语句用于条件判断，if语句有三种形式： if conditions then thenpart end if conditions then thenpart else elsepart end if conditions then thenpart elseif conditions then -- 可以有多个elseif语句块 elseifpart else elsepart end "},"chapter04/while.html":{"url":"chapter04/while.html","title":"while语句","keywords":"","body":"while语句 while语句用于循环，while语法如下： while conditions do whilepart end 实例： -- while_test.lua a = 10 while a 执行结果如下： $ lua while_test.lua a is: 10 a is: 11 a is: 12 a is: 13 a is: 14 a is: 15 a is: 16 a is: 17 a is: 18 a is: 19 "},"chapter04/repeat.html":{"url":"chapter04/repeat.html","title":"repeat语句","keywords":"","body":"repeat语句 与while和for不同的是，repeat语句的条件判断表达式在后面，这就意味着repeat语句至少要执行一次。 repeat语法如下： repeat repeatpart until conditions 实例： -- repeat_test.lua a = 10 repeat print(\"a is: \" .. a) a = a + 1 until a > 20 执行结果如下： $ lua repeat_test.lua a is: 10 a is: 11 a is: 12 a is: 13 a is: 14 a is: 15 a is: 16 a is: 17 a is: 18 a is: 19 a is: 20 "},"chapter04/for.html":{"url":"chapter04/for.html","title":"for语句","keywords":"","body":"for语句 Lua中有两种for循环： 数值for循环 泛型for循环 数值for循环 语法如下： for var=exp1,exp2,exp3 do statements end for将exp3作为exp1到exp2的步长，其中exp3可以忽略，默认步长是1。 注意 三个表达式只会执行一次。 for i=1,f(x) do -- f(x)只会执行一次 print(i) end for i=10,1,-1 do print(i) end 控制变量var是局部变量会被自动声明，且只在循环内部有效。如果需要保留var的值，则需要在循环中将其保存。 local found = nil for i=1,10 do if i == 9 then found = i break end end print(found) --> 9 循环过程中不要改变控制变量的值，那样做的结果是不可预知的。如果要退出循环，使用break语句。 泛型for循环 语法如下： for i,v in ipairs(t) do -- 遍历数组 statements end for k,v in pairs(t) do -- 遍历table statements end 实例： days = {\"Suanday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"} for i,v in ipairs(days) do print(i, v) end --[[执行结果如下： 1 Suanday 2 Monday 3 Tuesday 4 Wednesday 5 Thursday 6 Friday 7 Saturday ]] a = {a=1, b=2} for k,v in pairs(a) do print(k, v) end --[[执行结果如下： b 2 a 1 ]] "},"chapter04/break.html":{"url":"chapter04/break.html","title":"break语句","keywords":"","body":"break语句 break语句用来退出当前循环（for、repeat、while）。在循环外部不可以使用。 Lua语法要求break只能出现在block的结尾一句（也就是说：作为chunk的最后一句，或者在end之前，或者else前，或者until前）。 有时候为了调试或者其他目的需要在block的中间使用break，可以显式的使用do..end来实现。 a = 10 while a 15 then break end end --[[执行结果如下： 10 11 12 13 14 15 ]] "},"chapter04/return.html":{"url":"chapter04/return.html","title":"return语句","keywords":"","body":"return语句 return用来从函数返回结果，当一个函数自然结束结尾会有一个默认的return。 Lua语法要求return只能出现在block的结尾一句（也就是说：作为chunk的最后一句，或者在end之前，或者else前，或者until前）。 有时候为了调试或者其他目的需要在block的中间使用return，可以显式的使用do..end来实现： function foo () do return end statements end "},"chapter05/":{"url":"chapter05/","title":"函数","keywords":"","body":"函数 函数有两种用途： 完成指定的任务，这种情况下函数作为调用语句使用 计算并返回值，这种情况下函数作为赋值语句的表达式使用 语法如下： optional_function_scope function function_name(argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separated end optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数， 未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字local。 function_name: 指定函数名称。 argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 函数调用时，需要使用()表明是函数调用。 但是有一个特例，当函数只有一个参数，并且这个参数是字符串或表构造时，()是可选的。 print \"Hello World\" -- print(\"Hello World\") dofile 'a.lua' -- dofile('a.lua') f{x=10, y=20} -- f({x=10, y=20}) type{} -- type({}) Lua也提供了面向对象方式调用函数的方法，o:f(x)与o.f(o, x)是等价的。 Lua使用的函数可以是Lua编写也可以是其他语言编写，对于Lua程序员来说用什么语言实现的函数使用起来都一样。 Lua函数实参和形参的匹配与赋值语句类似，多余部分被忽略，缺少部分用nil补足。 function f(a, b) return a or b end f(3) -- a=3, b=nil f(3, 4) -- a=3, b=4 f(3, 4, 5) -- a=3, b=4 (5被忽略) "},"chapter05/multiple_results.html":{"url":"chapter05/multiple_results.html","title":"返回多个结果","keywords":"","body":"返回多个结果 Lua函数可以返回多个结果值，比如string.find，其返回匹配串“开始和结束的下标”（如果不存在匹配串返回nil）。 s, e = string.find(\"hello Lua users\", \"Lua\") print(s, e) --> 7 9 Lua函数中，在return后列出要返回的值得列表即可返回多值，如： function maximum(a) local mi = 1 -- maximum index local m = a[mi] -- maximum value for i,val in ipairs(a) do if val > m then mi = i m = val end end return m, mi end print(maximum({8,10,23,12,5})) --> 23 3 Lua总是调整函数返回值的个数去适用调用环境，当作为一个语句调用函数时，所有返回值被忽略。假设有如下三个函数： function foo0() end -- returns no results function foo1() return 'a' end -- returns 1 result function foo2() return 'a','b' end -- returns 2 results 第一，当作为表达式调用函数时，有以下几种情况： 当调用作为表达式最后一个参数或者仅有一个参数时，根据变量个数函数尽可能多地返回多个值，不足补nil，超出舍去。 其他情况下，函数调用仅返回第一个值（如果没有返回值为nil）。 x,y = foo2() -- x='a', y='b' x = foo2() -- x='a', 'b'被忽略 x,y,z = 10,foo2() -- x=10, y='a', z='b' x,y = foo0() -- x=nil, y=nil x,y = foo1() -- x='a', y=nil x,y,z = foo2() -- x='a', y='b', z=nil x,y = foo2(), 20 -- x='a', y=20 x,y = foo0(), 20, 30 -- x='nil', y=20, 30被忽略 第二，函数调用作为函数参数被调用时，和多值赋值是相同。 print(foo0()) -- (no results) print(foo1()) --> a print(foo2()) --> a b print(foo2(), 1) --> a 1 print(foo2() .. \"x\") --> ax 第三，函数调用在表构造函数中初始化时，和多值赋值时相同。 a = {foo0()} -- a = {} (an empty table) a = {foo1()} -- a = {'a'} a = {foo2()} -- a = {'a', 'b'} a = {foo0(), foo2(), 4} -- a[1] = nil, a[2] = 'a', a[3] = 4 第四，return f()这种类型的返回f()返回的所有值。 function foo(i) if i == 0 then return foo0() elseif i == 1 then return foo1() elseif i == 2 then return foo2() end end print(foo(1)) --> a print(foo(2)) --> a b print(foo(0)) -- (no results) print(foo(3)) -- (no results) 第五，可以使用圆括号强制使调用返回一个值。 print((foo0())) --> nil print((foo1())) --> a print((foo2())) --> a 第六，一个return语句如果使用圆括号将返回值括起来也将导致返回一个值。 function foo(i) if i == 0 then return (foo0()) elseif i == 1 then return (foo1()) elseif i == 2 then return (foo2()) end end print(foo(1)) --> a print(foo(2)) --> a b print(foo(0)) --> nil print(foo(3)) -- (no results) unpack 函数多值返回的特殊函数unpack，接受一个数组作为输入参数，返回数组的所有元素。 unpack被用来实现范型调用机制，在C语言中可以使用函数指针调用可变的函数，可以声明参数可变的函数，但不能两者同时可变。 在Lua中如果你想调用可变参数的可变函数只需要这样： f(unpack(a)) unpack返回a所有的元素作为f()的参数。 f = string.find a = {\"hello\", \"ll\"} print(f(unpack(a))) --> 3 4 "},"chapter05/arguments.html":{"url":"chapter05/arguments.html","title":"可变参数","keywords":"","body":"可变参数 Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（...）表示函数有可变的参数。 可以通过args = {...}的方式将参数放在一个叫args的表中，另外可以通过#args获取参数个数。 function average(...) result = 0 local args={...} for i,v in ipairs(args) do result = result + v end print(\"总共传入: \" .. #args .. \"个数\") return result/#args end print(\"平均值为: \" .. average(10,5,3,4,5,6)) --[[执行结果为： 总共传入: 6个数 平均值为: 5.5 ]] 有时候我们需要几个固定参数和一些可变参数： function select(n, ...) local args = {...} return args[n] end print(select(1, 1, 2, 3, 4)) --> 1 print(select(2, 1, 2, 3, 4)) --> 2 print(select(10, 1, 2, 3, 4)) --> nil "},"chapter06/":{"url":"chapter06/","title":"函数 -- 进阶篇","keywords":"","body":"函数 -- 进阶篇 Lua中的函数是带有词法定界（lexical scoping）的第一类值（first-class values）。 第一类值指：在Lua中函数和其他值（数值、字符串）一样，函数可以被存放在变量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。 词法定界指：被嵌套的函数可以访问他外部函数中的变量。这一特性给Lua提供了强大的编程能力。 Lua中关于函数稍微难以理解的是函数也可以没有名字，匿名的。 既然函数是值，那么表达式也可以创建函数了，函数定义也可以写成一个赋值语句，将类型为function的变量赋给一个变量。 function foo(x) return 2 * x end -- foo = function(x) return 2 * x end table标准库提供一个排序函数，接受一个表作为输入参数并且排序表中的元素。 这个函数必须能够对不同类型的值（字符串或者数值）按升序或者降序进行排序。 Lua不是尽可能多地提供参数来满足这些情况的需要，而是接受一个排序函数作为参数，排序函数接受两个排序元素作为输入参数，并且返回两者的大小关系。 network = { {name = \"grauna\", IP = \"210.26.30.34\"}, {name = \"arraial\", IP = \"210.26.30.23\"}, {name = \"lua\", IP = \"210.26.23.12\"}, {name = \"derain\", IP = \"210.26.23.20\"}, } -- 根据name排序 table.sort(network, function (a,b) return (a.name > b.name) end) -- 根据IP排序 table.sort(network, function (a,b) return (a.IP > b.IP) end) "},"chapter06/closures.html":{"url":"chapter06/closures.html","title":"闭包","keywords":"","body":"闭包 当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量。 下面看一个简单的例子，假定有一个学生姓名的列表和一个学生名和成绩对应的表；现在想根据学生的成绩从高到低对学生进行排序，可以这样做： names = {\"Peter\", \"Paul\", \"Mary\"} grades = {Mary = 10, Paul = 7, Peter = 8} table.sort(names, function(n1, n2) return grades[n1] > grades[n2] end) 假定创建一个函数实现此功能： function sortbygrade(names, grades) table.sort(names, function(n1, n2) return grades[n1] > grades[n2] end) end 例子中包含在sortbygrade函数内部的sort中的匿名函数可以访问sortbygrade的参数grades， 在匿名函数内部grades不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者 upvalue。 （upvalue意思有些误导，然而在Lua中他的存在有历史的根源，还有他比起external local variable简短）。 看下面的代码： function newCounter() local i = 0 return function() i = i + 1 return i end end c1 = newCounter() print(c1()) --> 1 print(c1()) --> 2 匿名函数使用upvalue i保存他的计数，当我们调用匿名函数的时候i已经超出了作用范围，因为创建i的函数newCounter已经返回了。 然而Lua用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的upvalues。 如果我们再次调用newCounter，将创建一个新的局部变量i，因此我们得到了一个作用在新的变量i上的新闭包。 c2 = newCounter() print(c2()) --> 1 print(c1()) --> 3 print(c2()) --> 2 c1、c2是建立在同一个函数上，但作用在同一个局部变量的不同实例上的两个不同的闭包。 从技术上说，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明。 闭包在上下文环境中提供很有用的功能，如前面我们见到的可以作为高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。 这一机制使得我们可以在Lua的函数世界里组合出奇幻的编程技术。 闭包也可用在回调函数中，比如在GUI环境中你需要创建一系列button， 但用户按下button时回调函数被调用，可能不同的按钮被按下时需要处理的任务有点区别。 具体来讲，一个十进制计算器需要 10 个相似的按钮，每个按钮对应一个数字，可以使用下面的函数创建他们： function digitButton(digit) return Button{ label = digit, action = function() add_to_display(digit) end } end 这个例子中我们假定Button是一个用来创建新按钮的工具，label是按钮的标签，action是按钮被按下时调用的回调函数。 闭包在完全不同的上下文中也是很有用途的。 因为函数被存储在普通的变量内我们可以很方便的重定义或者预定义函数。 通常当你需要原始函数有一个新的实现时可以重定义函数。 利用同样的特征我们可以创建一个安全的环境（也称作沙箱）， 当我们运行一段不信任的代码（比如我们运行网络服务器上获取的代码）时安全的环境是需要的， 比如我们可以使用闭包重定义io库的open函数来限制程序打开的文件。 do local oldOpen = io.open io.open = function(filename, mode) if access_OK(filename, mode) then return oldOpen(filename, mode) else return nil, \"access denied\" end end end "},"chapter06/tail_calls.html":{"url":"chapter06/tail_calls.html","title":"尾调用","keywords":"","body":"尾调用 Lua中函数的另一个有趣的特征是可以正确的处理尾调用（proper tail recursion）。 尾调用是一种类似在函数结尾的goto调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。 function f() return g() end g的调用是尾调用。 例子中f调用g后不会再做任何事情，这种情况下当被调用函数g结束时程序不需要返回到调用者f； 所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。一些编译器比如Lua解释器利用这种特性在处理尾调用时不使用额外的栈， 我们称这种语言支持正确的尾调用。 由于尾调用不需要使用栈空间，那么尾调用递归的层次可以无限制的。 例如下面调用不论n为何值不会导致栈溢出。 function foo(n) if n > 0 then return foo(n - 1) end end 需要注意的是：必须明确什么是尾调用。 一些调用者函数调用其他函数后也没有做其他的事情但不属于尾调用。比如： function f(x) g(x) return end 上面这个例子中f在调用g后，不得不丢弃g地返回值，所以不是尾调用，同样的下面几个例子也不是尾调用： return g(x) + 1 -- must do the addition return x or g(x) -- must adjust to 1 result return (g(x)) -- must adjust to 1 result Lua中类似return g(...)这种格式的调用是尾调用。 但是g和g的参数都可以是复杂表达式，因为Lua会在调用之前计算表达式的值。 例如下面的调用是尾调用： return x[i].foo(x[j] + a*b, i + j) 如果没有正确的尾调用，每次调用都要创建一个栈，多次调用后可能导致栈溢出。 但正确的尾调用可以无限制的尾调用，因为每次尾调用只是一个goto到另外一个函数并不是传统的函数调用。 "}}